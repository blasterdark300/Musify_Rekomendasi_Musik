# -*- coding: utf-8 -*-
"""musify7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HsEt_Fx5DgrTrnoXiGzfV2x0wb96nYkr

# 🎧 **Laporan Proyek Machine Learning - Krismono Sadi**

## 📌 Sistem Rekomendasi Lagu Spotify

### 🔍 Sumber Data

Dataset dikumpulkan melalui proses *scraping* menggunakan **Spotify Web API** resmi. Dokumentasi lengkap API dapat diakses melalui tautan berikut:

👉 [Spotify Developer API](https://developer.spotify.com/documentation/web-api?directory=true)

Dataset hasil *scraping* telah tersedia dan didokumentasikan secara terbuka di GitHub:

📁 [GitHub Repository - Musify Recommender](https://github.com/blasterdark300/musify-recommender)

---

## 🎵 Domain Proyek: Sistem Rekomendasi Musik

**Kategori Proyek**:

* Recommender System
* Information Retrieval
* Content-Based Filtering
* Machine Learning for Media & Entertainment

**Penjelasan**:

Proyek ini berada dalam domain sistem rekomendasi musik, yaitu cabang dari *Information Retrieval* dan *Machine Learning* yang berfokus pada pemberian rekomendasi lagu yang relevan kepada pengguna. Sistem ini menggunakan pendekatan **Content-Based Filtering**, yaitu memberikan rekomendasi berdasarkan kemiripan fitur lagu, seperti durasi dan popularitas.

Ciri khas sistem ini:

* Tidak bergantung pada data interaksi pengguna seperti *ratings*, *likes*, atau *play history*.
* Rekomendasi diberikan berdasarkan fitur konten lagu itu sendiri.
* Bukan termasuk dalam *Collaborative Filtering* karena tidak menggunakan *user profile*.

---

## 📖 **Project Overview**

Sistem rekomendasi musik merupakan komponen penting dalam platform streaming audio digital seperti Spotify. Mengingat jutaan lagu tersedia, sistem ini berperan dalam membantu pengguna menemukan musik yang sesuai dengan preferensi mereka secara efisien.

Pada proyek ini, dikembangkan sebuah sistem rekomendasi berbasis konten (**Content-Based Filtering**) yang menyarankan lagu-lagu mirip berdasarkan fitur numerik (contohnya: durasi) dan informasi terkait artis. Sistem ini tidak mengandalkan data eksplisit dari pengguna, sehingga proses rekomendasi sepenuhnya bergantung pada kesamaan konten antar lagu.

---

## 🧠 **Business Understanding**

### 🎯 Problem Statements

* Bagaimana merancang sistem rekomendasi yang mampu memberikan saran lagu yang relevan berdasarkan kemiripan fitur lagu?
* Bagaimana mengevaluasi performa sistem rekomendasi tanpa adanya data interaksi pengguna seperti rating atau riwayat pemutaran?

### ✅ Goals

* Mengembangkan sistem rekomendasi **Top-N Lagu** menggunakan pendekatan **Content-Based Filtering**.
* Melakukan evaluasi performa sistem dengan menggunakan metrik sederhana **Precision\@K**, berdasarkan asumsi bahwa lagu dari artis yang sama dianggap relevan.

### 💡 Solution Approach

* **Content-Based Filtering**: Sistem dibangun menggunakan fitur numerik dari lagu seperti `duration_ms`. Fitur ini dinormalisasi menggunakan **MinMaxScaler** sebelum digunakan dalam perhitungan kemiripan menggunakan **Cosine Similarity**.
* **Evaluasi Relevansi**: Karena tidak tersedia data eksplisit dari pengguna, lagu dari **artis yang sama** diasumsikan sebagai lagu relevan, dan pendekatan ini digunakan untuk menghitung **Precision\@K**.

---

Jika Anda menginginkan, saya juga dapat melanjutkan perbaikan bagian selanjutnya seperti **Data Preparation**, **Modeling**, atau **Evaluation**.

# 1. Import Library

# Penjelasan:
Pada tahap ini, kita mengimpor pustaka-pustaka yang dibutuhkan, seperti pandas untuk manipulasi data,
matplotlib dan seaborn untuk visualisasi, serta sklearn untuk preprocessing dan evaluasi model.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import random
import requests

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity

# Untuk evaluasi precision@k
from sklearn.metrics import precision_score

"""# 2. Download dan Load Dataset

Download dataset

dari github :

https://github.com/blasterdark300/musify-recommender/blob/main/spotify_cris_music1.csv
"""

url = "https://raw.githubusercontent.com/blasterdark300/musify-recommender/main/spotify_cris_music1.csv"
response = requests.get(url)

with open("spotify_cris_music1.csv", "wb") as f:
    f.write(response.content)

print("Download selesai!")

"""
# Penjelasan:
Dataset dimuat dari file CSV ke dalam DataFrame Pandas untuk mempermudah analisis dan pemrosesan data selanjutnya."""

path = "spotify_cris_music1.csv"
df = pd.read_csv(path)
print(f"Dataset berhasil dimuat dari: {path}")

"""# **🔍 Data Understanding**

**Sumber Data (tautan Github)** dan download datasetnya :

🔗 [github.com/blasterdark300/musify-recommender](https://github.com/blasterdark300/musify-recommender)

---
 Menampilkan 5 baris pertama
"""

print("\n===== 5 Baris Pertama Dataset =====")
print(df.head())

"""**Struktur Data (df.info(), shape, dtypes)**

### Tabel Struktur Data

| No | Kolom         | Non-Null Count | Tipe Data |
|----|---------------|----------------|-----------|
| 0  | name          | 5624           | object    |
| 1  | artist        | 5624           | object    |
| 2  | album         | 5624           | object    |
| 3  | popularity    | 5624           | int64     |
| 4  | explicit      | 5624           | bool      |
| 5  | release_date  | 5624           | object    |
| 6  | duration_ms   | 5624           | int64     |
| 7  | preview_url   | 0              | float64   |

**Total Baris**: 5624  
**Total Kolom**: 8  
**Penggunaan Memori**: ~313.2+ KB
"""

# Informasi struktur data
print("\nInfo Data:")
print(df.info())

"""**Jumlah data (baris dan kolom)**

Jumlah data: 5624 baris dan 8 kolom
"""

# Menampilkan jumlah baris dan kolom
rows, cols = df.shape
print(f"Jumlah data: {rows} baris dan {cols} kolom")

"""# Jumlah missing values

| Kolom         | Nilai Kosong |
| ------------- | ------------ |
| name          | 0            |
| artist        | 0            |
| album         | 0            |
| popularity    | 0            |
| explicit      | 0            |
| release\_date | 0            |
| duration\_ms  | 0            |
| preview\_url  | 5624         |
"""

print("\n===== Nilai Kosong per Kolom =====")
print(df.isnull().sum())

"""**Deskripsi Statistik (df.describe())**

| Statistik | popularity  | duration\_ms | preview\_url |
| --------- | ----------- | ------------ | ------------ |
| count     | 5624.000000 | 5624.000000  | 0.0          |
| mean      | 15.677809   | 197499.4232  | NaN          |
| std       | 15.031440   | 81228.9246   | NaN          |
| min       | 0.000000    | 7786.0000    | NaN          |
| 25%       | 4.000000    | 116571.0000  | NaN          |
| 50%       | 13.000000   | 217079.0000  | NaN          |
| 75%       | 24.000000   | 262133.0000  | NaN          |
| max       | 87.000000   | 511306.0000  | NaN          |
"""

# Statistik deskriptif
print("\nStatistik Deskriptif:")
print(df.describe())

"""**Cek Missing Value**

| Kolom         | Missing Values |
| ------------- | -------------- |
| name          | 0              |
| artist        | 0              |
| album         | 0              |
| popularity    | 0              |
| explicit      | 0              |
| release\_date | 0              |
| duration\_ms  | 0              |
| preview\_url  | 5624           |
"""

# Pemeriksaan missing value
print("\nMissing Values:")
print(df.isnull().sum())

"""**Cek Duplikat**

Jumlah duplikat dalam dataset: 4379
"""

# Cek duplikat
duplikat = df.duplicated().sum()
print(f"Jumlah duplikat dalam dataset: {duplikat}")

"""**Cek Outlier (tanpa hapus dulu, cukup identifikasi)**

Jumlah outlier per fitur:
popularity     188
duration_ms     12
preview_url      0
dtype: int64
"""

# Pilih hanya kolom numerik
numerik_df = df.select_dtypes(include=['float64', 'int64'])

# Cek Outlier dengan metode IQR pada kolom numerik
Q1 = numerik_df.quantile(0.25)
Q3 = numerik_df.quantile(0.75)
IQR = Q3 - Q1

# Tentukan batas bawah dan atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Identifikasi outlier untuk setiap kolom numerik
outliers = ((numerik_df < lower_bound) | (numerik_df > upper_bound)).sum()
print("Jumlah outlier per fitur:")
print(outliers)

"""# Visualisasi distribusi fitur"""

plt.figure(figsize=(12, 5))
sns.histplot(df['popularity'], kde=True, bins=30)
plt.title('Distribusi Popularitas Lagu')
plt.xlabel('Popularitas')
plt.ylabel('Jumlah Lagu')
plt.show()

plt.figure(figsize=(12, 5))
sns.histplot(df['duration_ms'] / 60000, kde=True, bins=30)
plt.title('Distribusi Durasi Lagu (menit)')
plt.xlabel('Durasi (menit)')
plt.ylabel('Jumlah Lagu')
plt.show()

"""# **🛠️ Data Preparation**

**Menghapus Outlier (gunakan IQR)**

pada tahap ini kita akan Untuk menghapus outlier, digunakan metode Interquartile Range (IQR), yaitu metode statistik yang mengidentifikasi data pencilan berdasarkan rentang kuart
"""

def remove_outliers_iqr(data, features):
    cleaned_data = data.copy()
    for feature in features:
        Q1 = cleaned_data[feature].quantile(0.25)
        Q3 = cleaned_data[feature].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        before = cleaned_data.shape[0]
        cleaned_data = cleaned_data[(cleaned_data[feature] >= lower_bound) & (cleaned_data[feature] <= upper_bound)]
        after = cleaned_data.shape[0]
        print(f"{feature}: Removed {before - after} outliers")
    return cleaned_data

""" **Menghapus Outlier dari Fitur Numerik**"""

numerical_features = df.select_dtypes(include=['float64', 'int64']).columns.tolist()
numerical_features.remove('preview_url')  # Biasanya kualitas digunakan sebagai target, jadi dikecualikan

df_cleaned = remove_outliers_iqr(df, numerical_features)

"""# Menghapus duplikat

pada tahap ini kita akan Untuk menghapus Berdasarkan nama dan artist untuk pembersihan banyaknya duplikat yang dimiliki oleh dataset (.csv)

# Hapus duplikat berdasarkan 'name' dan 'artist'
"""

print(f"\nJumlah data duplikat berdasarkan 'name' dan 'artist': {df.duplicated(subset=['name', 'artist']).sum()}")

df.drop_duplicates(subset=['name', 'artist'], inplace=True)

print(f"Jumlah data setelah drop duplikat: {df.shape[0]}")



"""# Cek missing value lagi setelah drop duplikat

Kode ini berfungsi untuk mengecek dan menampilkan jumlah nilai kosong (missing values) di setiap kolom setelah proses menghapus data duplikat pada DataFrame df.

Penjelasan detail:

df.isnull() menghasilkan DataFrame baru dengan nilai True untuk setiap sel yang kosong (NaN), dan False untuk yang tidak kosong.

.sum() pada hasil tersebut akan menjumlahkan True (yang dianggap 1) per kolom, sehingga menghasilkan jumlah nilai kosong di masing-masing kolom.

print() menampilkan hasil tersebut ke layar.
"""

print("\nNilai kosong per kolom setelah drop duplikat:")
print(df.isnull().sum())

"""# Mengonversi release_date ke datetime

Binning pada fitur numerik (seperti popularity dan duration_ms) adalah teknik mengelompokkan nilai-nilai kontinu menjadi beberapa kategori atau interval diskrit. Misalnya, rentang nilai popularity 0–100 bisa dibagi menjadi kategori rendah, sedang, dan tinggi. Tujuannya adalah menyederhanakan data, mengurangi noise, dan memudahkan analisis atau model yang lebih sensitif terhadap kategori dibandingkan nilai kontinu.

---

Kode ini mengonversi kolom release_date di DataFrame df menjadi tipe data tanggal/waktu (datetime). Jika ada data yang tidak bisa diubah menjadi tanggal yang valid, maka akan diubah menjadi NaT (Not a Time) karena parameter errors='coerce'.
"""

df['release_date'] = pd.to_datetime(df['release_date'], errors='coerce')

"""# Isi missing value pada fitur numerik populer jika ada, dengan median

Kode ini digunakan untuk mengisi nilai kosong pada kolom numerik dengan nilai median kolom tersebut agar data menjadi lengkap dan siap untuk analisis selanjutnya. Teknik ini membantu mencegah error saat pemrosesan data dan mengurangi bias yang mungkin muncul jika nilai kosong dibiarkan.
"""

for col in ['popularity', 'duration_ms']:
    if df[col].isnull().sum() > 0:
        median_val = df[col].median()
        df[col].fillna(median_val, inplace=True)
        print(f"Missing value di kolom '{col}' diisi dengan median: {median_val}")

"""# Binning pada fitur numerik (popularity dan duration_ms)

Penjelasan singkat:

Kode ini mengelompokkan (binning) nilai fitur numerik popularity dan duration_ms menjadi kategori yang lebih mudah dipahami, seperti "Low", "Medium", "High" untuk popularitas, dan "Short", "Medium", "Long" untuk durasi lagu dalam menit.
"""

# Binning pada fitur popularity
bins_popularity = [0, 20, 40, 60, 80, 100]
labels_popularity = ['Very Low', 'Low', 'Medium', 'High', 'Very High']
df['popularity_binned'] = pd.cut(df['popularity'], bins=bins_popularity, labels=labels_popularity, include_lowest=True)

# Binning pada fitur duration_ms (dikonversi ke menit)
df['duration_min'] = df['duration_ms'] / 60000
bins_duration = [0, 2, 4, 6, np.inf]
labels_duration = ['Short', 'Medium', 'Long', 'Very Long']
df['duration_binned'] = pd.cut(df['duration_min'], bins=bins_duration, labels=labels_duration, include_lowest=True)

print("\nHasil binning (5 baris pertama):")
print(df[['popularity', 'popularity_binned', 'duration_min', 'duration_binned']].head())

"""# Scaling fitur numerik

Penjelasan singkat:

Kode ini melakukan normalisasi (scaling) pada fitur numerik popularity dan duration_ms menggunakan MinMaxScaler, agar nilai fitur berada dalam rentang 0 sampai 1. Sebelum itu, jika ada data yang hilang (missing value), akan diisi dengan nol agar proses scaling tidak gagal.

Kode itu cek apakah ada nilai kosong (missing) di fitur numerik.
Kalau ada, isi kosongnya dengan 0 supaya tidak error saat normalisasi.
Setelah itu, fitur numerik dinormalisasi dengan scaler.

Skalasi Fitur Numerik

1. Tentukan fitur numerik yang ingin dinormalisasi
"""

features = ['popularity', 'duration_ms']

"""2. Inisialisasi scaler"""

scaler = MinMaxScaler()

"""3. Salin dataframe agar tidak mengubah df asli"""

df_scaled = df.copy()

"""4. Lakukan scaling fitur numerik dengan MinMaxScaler (0–1)"""

df_scaled[features] = scaler.fit_transform(df_scaled[features])

"""5. (Opsional) Cetak hasil normalisasi untuk verifikasi"""

print("Contoh data setelah scaling:")
print(df_scaled[features].head())

"""# 5. Modeling (Content-Based Filtering)

Metode Content-Based Filtering digunakan untuk merekomendasikan lagu-lagu yang memiliki karakteristik mirip dengan lagu yang dipilih pengguna. Pendekatan ini berfokus pada fitur numerik dari lagu — seperti popularitas dan durasi — yang telah melalui proses penskalaan agar berada dalam rentang nilai yang sebanding.

Untuk mengukur tingkat kemiripan antar lagu, digunakan metrik cosine similarity, yaitu ukuran matematis yang menghitung sudut antara dua vektor fitur dalam ruang multidimensi. Semakin kecil sudut antara dua vektor, semakin tinggi nilai kemiripan (mendekati 1), yang menandakan bahwa lagu-lagu tersebut memiliki profil karakteristik yang serupa.

---

Penjelasan singkat:
cosine_similarity(df_scaled[features])
Menghitung seberapa mirip setiap lagu dengan lagu lain berdasarkan fitur numerik seperti popularitas dan durasi, menggunakan metode cosine similarity.

Fungsi recommend_songs
Menerima nama lagu sebagai input dan mengembalikan daftar lagu lain yang paling mirip berdasarkan skor similarity, menampilkan informasi nama, artis, popularitas, dan durasi.
"""

# Menghitung cosine similarity antara lagu berdasarkan fitur numerik (popularity, duration_ms)
cosine_sim = cosine_similarity(df_scaled[features])

# Fungsi rekomendasi lagu berdasarkan lagu input
def recommend_songs(song_name, df, cosine_sim, top_k=5):
    # Cek apakah lagu ada di dataset
    if song_name not in df['name'].values:
        print(f"Lagu '{song_name}' tidak ditemukan dalam dataset.")
        return pd.DataFrame()

    # Indeks lagu input
    idx = df.index[df['name'] == song_name][0]

    # Ambil skor similarity untuk lagu tersebut
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Urutkan skor similarity secara descending, kecuali lagu itu sendiri
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Ambil top_k lagu teratas (mengabaikan lagu itu sendiri yang ada di posisi pertama)
    sim_scores = sim_scores[1:top_k+1]

    # Ambil indeks lagu-lagu rekomendasi
    song_indices = [i[0] for i in sim_scores]

    # Tampilkan nama lagu dan artis yang direkomendasikan
    recommended = df.iloc[song_indices][['name', 'artist', 'popularity', 'duration_min']]
    return recommended

"""# 6. Hasil Top-N Rekomendasi

Penjelasan singkat:

song_input = df['name'].iloc[0]
Mengambil judul lagu pertama di dataset secara otomatis sebagai input untuk rekomendasi.

recommend_songs(...)
Memanggil fungsi rekomendasi lagu untuk mencari 10 lagu yang mirip dengan lagu input.

Bagian print header dan loop:
Menampilkan hasil rekomendasi dalam format tabel teks rapi di console, dengan kolom nomor, nama lagu, artis, popularitas, dan durasi dalam menit.

Pakai lagu pertama dari dataset secara otomatis sebagai input lagu
"""

song_input = df['name'].iloc[0]

print(f"Rekomendasi lagu mirip dengan '{song_input}':\n")

recommendations = recommend_songs(song_input, df, cosine_sim, top_k=5)

"""Print header tabel"""

print(f"{'No':<4} | {'Name':<25} | {'Artist':<20} | {'Popularity':<10} | {'Duration (min)':<14}")
print("-" * 80)

# Print tiap baris rekomendasi
for i, row in enumerate(recommendations.itertuples(), 1):
    print(f"{i:<4} | {row.name:<25} | {row.artist:<20} | {row.popularity:<10} | {row.duration_min:.2f}")

"""# 7. Evaluation (Precision@K)

Penjelasan:

Fungsi ini mengukur precision@k, yaitu seberapa banyak dari top-k rekomendasi lagu yang berasal dari artis yang sama dengan lagu input.

recommended_df adalah DataFrame lagu yang direkomendasikan.

original_artist adalah nama artis dari lagu input.

k adalah jumlah rekomendasi yang dihitung (misal top 5).

Hasilnya adalah nilai antara 0 dan 1, semakin dekat ke 1 berarti rekomendasi lebih relevan (banyak lagu dari artis yang sama).

Hitung berapa banyak lagu dari artis yang sama di top-k rekomendasi
"""

def precision_at_k(recommended_df, original_artist, k=5):
    recommended_k = recommended_df.head(k)
    true_positives = sum(recommended_k['artist'] == original_artist)
    return true_positives / k

"""Evaluasi lagu contoh dengan tambahan informasi popularity dan durasi"""

if song_input in df['name'].values:
    original_artist = df.loc[df['name'] == song_input, 'artist'].values[0]
    popularity = df.loc[df['name'] == song_input, 'popularity'].values[0]
    duration_min = df.loc[df['name'] == song_input, 'duration_min'].values[0]

    precision = precision_at_k(recommendations, original_artist, k=5)

    print(f"\nEvaluasi lagu   : '{song_input}'")
    print(f"Artis           : {original_artist}")
    print(f"Popularity      : {popularity}")
    print(f"Durasi (menit)  : {duration_min:.2f}")
    print(f"Precision@5     : {precision:.2f}")
else:
    print("Lagu input tidak ditemukan, tidak bisa evaluasi precision@k.")

"""# 8. Tambahan: Top Populer dan Terbaru

### Fungsi `top_popular_songs`

**Tujuan:**  
Mengambil daftar lagu terpopuler berdasarkan nilai kolom `popularity`.

**Langkah kerja:**  
- Pilih kolom `name`, `artist`, dan `popularity`.  
- Hapus duplikat agar setiap lagu/artis unik.  
- Urutkan berdasarkan `popularity` dari tinggi ke rendah.  
- Ambil `top_n` lagu teratas (default 5).

---

### Fungsi `top_recent_songs`

**Tujuan:**  
Mengambil daftar lagu terbaru berdasarkan `release_date`.

**Langkah kerja:**  
- Pilih kolom `name`, `artist`, dan `release_date`.  
- Hapus duplikat.  
- Urutkan berdasarkan tanggal rilis dari terbaru ke terlama.  
- Ambil `top_n` lagu terbaru.

---

### Penggunaan

Mencetak tabel markdown berisi 5 lagu terpopuler dan 5 lagu terbaru agar mudah dibaca di terminal atau notebook.
"""

def top_popular_songs(df, top_n=5):
    return df[['name', 'artist', 'popularity']].drop_duplicates().sort_values(by='popularity', ascending=False).head(top_n)

def top_recent_songs(df, top_n=5):
    return df[['name', 'artist', 'release_date']].drop_duplicates().sort_values(by='release_date', ascending=False).head(top_n)

print("\nTop 5 Lagu Terpopuler:")
print(top_popular_songs(df, 5).to_markdown(index=False))

print("\nTop 5 Lagu Terbaru:")
print(top_recent_songs(df, 5).to_markdown(index=False))

"""### ✅ Apakah Model Telah Menjawab Problem Statements?

Iya Tentu, Ini Hasilnya :

**🔹 Problem Statement 1:** *Bagaimana memberikan rekomendasi lagu yang relevan berdasarkan fitur lagu?*

✔️ Model menggunakan fitur numerik seperti `popularity` dan `duration_ms` yang telah dinormalisasi menggunakan **MinMaxScaler**. Kemudian, sistem menghitung **Cosine Similarity** antar lagu untuk mengidentifikasi kemiripan konten. Hasil rekomendasi menunjukkan lagu-lagu dengan karakteristik serupa, menjawab kebutuhan akan rekomendasi berbasis konten.

**🔹 Problem Statement 2:** *Bagaimana mengevaluasi sistem rekomendasi tanpa data interaksi pengguna?*

✔️ Sistem dievaluasi menggunakan metrik **Precision\@K**, dengan pendekatan bahwa lagu dari artis yang sama dianggap relevan sebagai *proxy ground truth*. Meskipun pendekatan ini bersifat heuristik, metode ini cukup representatif sebagai evaluasi awal sebelum data eksplisit pengguna tersedia.

---

### 🎯 Apakah Model Telah Mencapai Tujuan? **(Goals)**

✔️ Evaluasi & Insight
📌 Evaluasi lagu: '｢ごめん｣で済むなら恋などしない'
🎤 Artis: 白皇学院生徒会三人娘 starring 矢作紗友里＆中尾衣里＆浅野真澄
📉 Popularity: 0
⏱️ Durasi: 3.11 menit
🎯 Precision@5: 0.60

Hasil Evaluasi Relevan:
![Hasil Evaluasi Relevan](img/evaluasi1.png)

✔️ Sistem berhasil menghasilkan daftar Top-N rekomendasi lagu berdasarkan kemiripan fitur konten, selaras dengan tujuan utama proyek.

✔️ Evaluasi menggunakan Precision@5 = 0.60 menunjukkan bahwa sistem mampu memberikan 3 rekomendasi relevan dari 5. Hal ini menunjukkan performa yang cukup baik, terutama pada lagu dengan popularitas nol, menandakan sistem tidak bias terhadap lagu populer.

✔️ Evaluasi menggunakan Precision@K memberikan dasar kuantitatif yang jelas untuk mengukur performa sistem, serta dapat digunakan sebagai baseline pada pengembangan selanjutnya.

✔️ Sistem juga mendukung skenario cold-start, karena tidak memerlukan data histori pengguna, sehingga cocok untuk pengguna baru atau lagu baru dalam sistem.


---

### 📈 Solution Approach

✔️ Pendekatan **Content-Based Filtering** terbukti efektif dalam memberikan rekomendasi pada dataset ini yang berfokus pada fitur konten seperti `popularity` dan `duration_ms`.

✔️ Sistem mampu meningkatkan pengalaman eksplorasi musik dengan menyarankan lagu-lagu yang memiliki karakteristik serupa, mendukung personalisasi awal tanpa memerlukan data interaksi.

✔️ Solusi ini **scalable** dan dapat dikembangkan menjadi sistem hybrid di masa depan dengan menggabungkan data eksplisit pengguna seperti rating atau histori pemutaran.

✔️ Proses preprocessing seperti konversi `release_date` ke tipe `datetime` membuka peluang untuk analisis tambahan berbasis waktu, seperti tren musik berdasarkan tahun rilis.

---

### 🧾 Kesimpulan Evaluasi

Model sistem rekomendasi lagu berbasis konten yang dikembangkan telah berhasil menjawab problem statement dan mencapai goals yang ditetapkan. Evaluasi dengan **Precision\@K** menunjukkan performa awal yang memadai untuk sistem rekomendasi tanpa data pengguna. Pendekatan ini efektif sebagai **baseline model** dan siap untuk ditingkatkan melalui pendekatan hybrid atau integrasi data pengguna ke depannya.

---

"""